---
layout: post
title: Kafka란
#subtitle: 'til'
categories: kafka
# tags: asynchronous
comments: false
order: 1
---

### 카프카란 (작성중)

![스크린샷-2023-05-24-오후-11 32 48 (1)](https://github.com/heejung-gjt/heejung-gjt.github.io/assets/64240637/42dbb092-0f87-4424-8846-41d19d98ce19)

[이미지 참고 블로그](https://velog.io/@kero88/Apache-Kafka)

카프카(Apache Kafka)는 분산 스트리밍 플랫폼으로 대량의 실시간 데이터를 안정적이고 확장 가능한 방식으로 처리하는 데 사용된다. 다양한 소스로부터 대량의 데이터를 수집하고, 실시간으로 처리 및 전송하여 실시간 데이터 파이프라인을 구축하는 데 적합하다.

- 분산 아키텍처: 카프카는 분산 아키텍처로 설계되어 있어, 여러 __브로커__ 로 구성된 __클러스터__ 형태로 동작한다. 이 클러스터는 데이터를 __파티션__ 으로 분할하고 여러 브로커에 저장하여 데이터의 안정성과 확장성을 제공한다.

- 내구성과 안정성: 카프카는 데이터를 디스크에 영속적으로 저장하여 내구성을 제공한다. 데이터는 설정에 따라 일정 기간 동안 보존되며, 데이터 손실 없이 안정적으로 처리될 수 있다.

- 메시지 기반 아키텍처: 카프카는 메시지 기반 아키텍처를 가지고 있어, 데이터를 작은 단위의 메시지로 처리합니다. 이를 통해 실시간 처리와 스트리밍 애플리케이션에 적합한 환경을 제공한다.

쉽게 말해 카프카는 대량의 데이터를 수집, 저장, 처리하고 실시간으로 전송하기 위한 플랫폼으로, 데이터를 생성하는 __프로듀서__ 와 데이터를 소비하는 __컨슈머__ 사이의 중간에 위치하여 데이터를 효율적으로 관리한다.   

카프카는 대량의 데이터를 안정적으로 처리하고 실시간으로 전송하는 데 적합하다.   

---

### 카프카의 구성 요소

카프카의 구성요소를 알아보았다.   

__프로듀서(Producer)__: 프로듀서는 ```데이터를 생성하고 카프카 클러스터로 보내는 역할```을 합니다. 데이터를 하나 이상의 토픽에 퍼블리시(게시)하여 브로커로 전달됩니다. 예를 들어, 로그 메시지를 생성하여 로그 토픽에 퍼블리시하는 프로듀서를 만들 수 있습니다.

__토픽(Topic)__: 토픽은 ```데이터가 퍼블리싱되고 컨슈머가 구독하는 주제를 나타냅니다```. 각 토픽은 하나 이상의 파티션으로 분할될 수 있습니다. 파티션은 브로커에 분산 저장되는 데이터의 단위입니다. 토픽은 데이터의 유형이나 주제에 따라 구성됩니다.

__브로커(Broker)__: 브로커는 카프카 클러스터의 구성원입니다. ```여러 개의 브로커가 클러스터를 형성하여 데이터를 저장하고 관리```합니다. 브로커는 ```데이터를 수신하고 디스크에 영속적으로 저장```하며, 프로듀서와 컨슈머 간의 통신을 조율합니다.

__컨슈머(Consumer)__: 컨슈머는 ```토픽에서 데이터를 읽어오고 처리하는 역할```을 합니다. 특정 토픽의 하나 이상의 파티션에서 데이터를 소비하며, 각 컨슈머는 자신이 읽어야 하는 파티션을 추적합니다. 데이터는 컨슈머가 읽을 때까지 보존되며, 컨슈머는 자체적으로 데이터를 소비하는 비즈니스 로직을 구현할 수 있습니다.

__컨슈머 그룹(Consumer Group)__: 컨슈머 그룹은 하나 이상의 컨슈머로 구성됩니다. ```특정 토픽의 파티션에서 데이터를 소비하는 컨슈머 그룹은 각 컨슈머가 서로 다른 파티션을 소비하도록 조정```됩니다. 이를 통해 데이터의 병렬 처리와 확장성을 구현할 수 있습니다. 컨슈머 그룹은 ```같은 그룹 내에서 중복 소비를 방지하기 위해 오프셋(Offset)을 사용하여 읽어야 할 위치를 추적```합니다.

__카프카 클러스터(Kafka Cluster)__: 카프카 클러스터는 ```여러 개의 브로커로 구성된 분산 시스템```입니다. 클러스터는 고가용성을 제공하여 하나 이상의 브로커가 실패해도 시스템이 계속해서 동작할 수 있도록 합니다. 브로커 간의 데이터 복제를 통해 데이터의 내구성을 보장하고, 브로커의 추가 또는 제거를 통해 클러스터의 확장성을 조정할 수 있습니다.


브로커 안에 컨슈머가 구독하는 토픽들이 있고 토픽에 해당되는 메시지들이 들어가 있다. 해당 메시지는 프로듀서를 통해 넣고 컨슈머가 메시지를 읽어서 처리하는 방식이다